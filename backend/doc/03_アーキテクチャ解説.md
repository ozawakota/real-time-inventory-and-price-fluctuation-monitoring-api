# ğŸ—ï¸ FastAPI ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åœ¨åº«ãƒ»ä¾¡æ ¼ç›£è¦–API ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è§£èª¬

## ğŸ“– ç›®æ¬¡

1. [ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“åƒ](#ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“åƒ)
2. [ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£](#ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£)
3. [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ](#ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ)
4. [ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡](#ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡)
5. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
6. [ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£](#ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£)
7. [ç›£è¦–ãƒ»ãƒ­ã‚°](#ç›£è¦–ãƒ­ã‚°)

---

## ğŸŒ ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“åƒ

### ğŸ”§ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```mermaid
graph TB
    subgraph "Frontend Layer"
        UI[React/Vue App]
        WS_CLIENT[WebSocket Client]
    end

    subgraph "API Gateway Layer"
        NGINX[Nginx Reverse Proxy]
    end

    subgraph "Application Layer"
        API[FastAPI Server]
        WS[WebSocket Handler]
        WORKER[Background Worker]
    end

    subgraph "Business Logic Layer"
        INVENTORY_SVC[Inventory Service]
        PRICE_SVC[Price Service]
        ALERT_SVC[Alert Service]
        WEBSOCKET_MGR[WebSocket Manager]
    end

    subgraph "Data Layer"
        POSTGRES[(PostgreSQL)]
        REDIS[(Redis)]
    end

    subgraph "External Services"
        EMAIL[Email Service]
        WEBHOOK[Webhook Service]
    end

    UI --> NGINX
    WS_CLIENT --> NGINX
    NGINX --> API
    NGINX --> WS

    API --> INVENTORY_SVC
    API --> PRICE_SVC
    WS --> WEBSOCKET_MGR

    INVENTORY_SVC --> POSTGRES
    PRICE_SVC --> POSTGRES
    ALERT_SVC --> EMAIL

    INVENTORY_SVC --> REDIS
    PRICE_SVC --> REDIS
    WEBSOCKET_MGR --> REDIS

    REDIS --> WS
    WORKER --> WEBHOOK
```

### âš¡ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯è©³ç´°

#### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ (Python)
```yaml
Core Framework:
  - FastAPI 0.104.1      # éåŒæœŸWebãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
  - Uvicorn 0.24.0       # ASGI ã‚µãƒ¼ãƒãƒ¼
  - Pydantic 2.5.0       # ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

Database:
  - SQLAlchemy 2.0.23    # éåŒæœŸORM
  - Asyncpg 0.29.0       # PostgreSQL éåŒæœŸãƒ‰ãƒ©ã‚¤ãƒãƒ¼
  - Alembic 1.13.0       # ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ãƒ¼ãƒ«

Caching & Messaging:
  - Redis 5.0.1          # ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢
  - AioRedis 2.0.1       # Redis éåŒæœŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

Authentication & Security:
  - Python-Jose 3.3.0    # JWT ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  - Passlib 1.7.4        # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–

Monitoring:
  - Structlog 23.2.0     # æ§‹é€ åŒ–ãƒ­ã‚°
```

#### ã‚¤ãƒ³ãƒ•ãƒ©
```yaml
Database:
  - PostgreSQL 15        # ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
  - Redis 7               # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°

Containerization:
  - Docker                # ã‚³ãƒ³ãƒ†ãƒŠåŒ–
  - Docker Compose        # ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒ

Web Server:
  - Nginx                 # ãƒªãƒãƒ¼ã‚¹ãƒ—ãƒ­ã‚­ã‚· (æœ¬ç•ªç”¨)
```

### ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼å›³

#### API ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ãƒ­ãƒ¼
```
1. Client Request
   â†“
2. FastAPI Router
   â†“  
3. Pydantic Validation
   â†“
4. Service Layer (Business Logic)
   â†“
5. Database/Cache Query
   â†“
6. Response Serialization
   â†“
7. Client Response
```

#### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ãƒ•ãƒ­ãƒ¼
```
1. Data Change (API)
   â†“
2. Service Layer Update
   â†“
3. Redis Pub/Sub Publish
   â†“
4. WebSocket Manager
   â†“
5. All Connected Clients
```

---

## ğŸ›ï¸ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã¨è²¬å‹™

```
app/
â”œâ”€â”€ ğŸŒ api/              # API Interface Layer
â”‚   â””â”€â”€ v1/
â”‚       â”œâ”€â”€ api.py       # ãƒ«ãƒ¼ã‚¿ãƒ¼é›†ç´„
â”‚       â””â”€â”€ endpoints/   # ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©
â”‚
â”œâ”€â”€ âš™ï¸ core/             # Core Configuration Layer
â”‚   â”œâ”€â”€ config.py        # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
â”‚   â”œâ”€â”€ database.py      # DBæ¥ç¶šãƒ»ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
â”‚   â””â”€â”€ redis_client.py  # Redis æ¥ç¶šç®¡ç†
â”‚
â”œâ”€â”€ ğŸ—„ï¸ models/          # Data Model Layer
â”‚   â”œâ”€â”€ inventory.py     # åœ¨åº«ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
â”‚   â””â”€â”€ price.py         # ä¾¡æ ¼ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
â”‚
â”œâ”€â”€ ğŸ“‹ schemas/          # Data Validation Layer
â”‚   â”œâ”€â”€ inventory.py     # åœ¨åº«ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ¼ãƒ
â”‚   â””â”€â”€ price.py         # ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ¼ãƒ
â”‚
â”œâ”€â”€ ğŸ”§ services/        # Business Logic Layer
â”‚   â”œâ”€â”€ inventory_service.py  # åœ¨åº«æ“ä½œãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”œâ”€â”€ price_service.py      # ä¾¡æ ¼æ“ä½œãƒ­ã‚¸ãƒƒã‚¯
â”‚   â””â”€â”€ websocket_manager.py  # ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡
â”‚
â””â”€â”€ ğŸ“„ main.py          # Application Entry Point
```

### ğŸ¯ å„å±¤ã®è©³ç´°è§£èª¬

#### 1. API Interface Layer (`api/`)
**è²¬å‹™**: HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†ã€ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

```python
# api/v1/endpoints/inventory.py
from fastapi import APIRouter, Depends, HTTPException, status
from app.services.inventory_service import InventoryService
from app.schemas.inventory import InventoryCreate, InventoryResponse

router = APIRouter()

@router.post("/", response_model=InventoryResponse, status_code=status.HTTP_201_CREATED)
async def create_inventory_item(
    item: InventoryCreate,
    service: InventoryService = Depends()
):
    """æ–°è¦åœ¨åº«ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆ"""
    try:
        return await service.create_inventory_item(item)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="Internal server error")
```

#### 2. Business Logic Layer (`services/`)
**è²¬å‹™**: ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã€ãƒ‡ãƒ¼ã‚¿æ“ä½œã€å¤–éƒ¨é€£æº

```python
# services/inventory_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.inventory import Inventory
from app.core.redis_client import get_redis_client

class InventoryService:
    def __init__(self, db: AsyncSession):
        self.db = db
        
    async def create_inventory_item(self, item_data: InventoryCreate) -> Inventory:
        """åœ¨åº«ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯"""
        
        # 1. ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«æ¤œè¨¼
        await self._validate_sku_unique(item_data.sku)
        await self._validate_stock_levels(item_data)
        
        # 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜
        db_item = Inventory(**item_data.model_dump())
        self.db.add(db_item)
        await self.db.commit()
        await self.db.refresh(db_item)
        
        # 3. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
        await self._update_cache(db_item)
        
        # 4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥
        await self._notify_websocket_clients(db_item, "created")
        
        # 5. ã‚¢ãƒ©ãƒ¼ãƒˆå‡¦ç†
        if db_item.is_low_stock:
            await self._send_low_stock_alert(db_item)
            
        return db_item
```

#### 3. Data Model Layer (`models/`)
**è²¬å‹™**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã€ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š

```python
# models/inventory.py
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime
from sqlalchemy.sql import func
from app.core.database import Base

class Inventory(Base):
    __tablename__ = "inventory_items"
    
    id = Column(Integer, primary_key=True, index=True)
    sku = Column(String(100), unique=True, index=True, nullable=False)
    name = Column(String(255), nullable=False)
    stock_quantity = Column(Integer, default=0)
    reserved_quantity = Column(Integer, default=0)
    min_stock_level = Column(Integer, default=10)
    cost_price = Column(Float, default=0.0)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    @property
    def available_quantity(self) -> int:
        """åˆ©ç”¨å¯èƒ½åœ¨åº«æ•°"""
        return max(0, self.stock_quantity - self.reserved_quantity)
    
    @property
    def is_low_stock(self) -> bool:
        """åœ¨åº«ä¸è¶³åˆ¤å®š"""
        return self.available_quantity <= self.min_stock_level
```

#### 4. Data Validation Layer (`schemas/`)
**è²¬å‹™**: å…¥åŠ›ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã€å‹å®‰å…¨æ€§ã€APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆ

```python
# schemas/inventory.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime

class InventoryBase(BaseModel):
    """åŸºæœ¬åœ¨åº«ã‚¹ã‚­ãƒ¼ãƒ"""
    sku: str = Field(..., min_length=1, max_length=100, description="å•†å“ã‚³ãƒ¼ãƒ‰")
    name: str = Field(..., min_length=1, max_length=255, description="å•†å“å")
    stock_quantity: int = Field(0, ge=0, description="åœ¨åº«æ•°é‡")
    min_stock_level: int = Field(10, ge=0, description="æœ€å°åœ¨åº«ãƒ¬ãƒ™ãƒ«")
    cost_price: float = Field(0.0, ge=0, description="åŸä¾¡")

class InventoryCreate(InventoryBase):
    """åœ¨åº«ä½œæˆç”¨ã‚¹ã‚­ãƒ¼ãƒ"""
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "sku": "LAPTOP-001",
                "name": "ã‚²ãƒ¼ãƒŸãƒ³ã‚°ãƒãƒ¼ãƒˆPC",
                "stock_quantity": 25,
                "min_stock_level": 5,
                "cost_price": 180000.0
            }
        }
    )

class InventoryResponse(InventoryBase):
    """API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã‚¹ã‚­ãƒ¼ãƒ"""
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    available_quantity: int
    is_low_stock: bool
    created_at: datetime
    updated_at: datetime
```

### ğŸ”„ ä¾å­˜æ€§æ³¨å…¥ (Dependency Injection)

#### FastAPI Depends ã‚·ã‚¹ãƒ†ãƒ 

```python
# core/dependencies.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_async_session
from app.services.inventory_service import InventoryService

async def get_inventory_service(
    db: AsyncSession = Depends(get_async_session)
) -> InventoryService:
    """åœ¨åº«ã‚µãƒ¼ãƒ“ã‚¹ã®ä¾å­˜æ€§æ³¨å…¥"""
    return InventoryService(db)

# ä½¿ç”¨ä¾‹
@router.post("/")
async def create_item(
    item: InventoryCreate,
    service: InventoryService = Depends(get_inventory_service)
):
    return await service.create_inventory_item(item)
```

#### åˆ©ç‚¹
- **ç–çµåˆ**: ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ã®ä¾å­˜æ€§æœ€å°åŒ–
- **ãƒ†ã‚¹ãƒˆã—ã‚„ã™ã•**: ãƒ¢ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ³¨å…¥ãŒç°¡å˜
- **å†åˆ©ç”¨æ€§**: ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹ã®è¤‡æ•°ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã®å…±æœ‰

---

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

### ğŸ“Š ERå›³

```mermaid
erDiagram
    INVENTORY_ITEMS {
        int id PK
        string sku UK
        string name
        string description
        string category
        int stock_quantity
        int reserved_quantity
        float weight
        string dimensions
        float cost_price
        int min_stock_level
        int max_stock_level
        boolean is_active
        boolean is_trackable
        datetime created_at
        datetime updated_at
    }

    PRICES {
        int id PK
        int inventory_id FK
        float selling_price
        float cost_price
        float discount_price
        string currency
        float margin_percent
        float markup_percent
        boolean is_active
        boolean requires_approval
        datetime effective_from
        datetime effective_until
        datetime created_at
        datetime updated_at
    }

    PRICE_HISTORY {
        int id PK
        int inventory_id FK
        float old_price
        float new_price
        float price_change_percent
        float price_change_amount
        string change_reason
        string changed_by
        string change_type
        string notes
        datetime changed_at
    }

    INVENTORY_ITEMS ||--o{ PRICES : has
    INVENTORY_ITEMS ||--o{ PRICE_HISTORY : tracks
```

### ğŸ”‘ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒè©³ç´°

#### åœ¨åº«ãƒ†ãƒ¼ãƒ–ãƒ« (`inventory_items`)
```sql
CREATE TABLE inventory_items (
    id SERIAL PRIMARY KEY,
    sku VARCHAR(100) UNIQUE NOT NULL,        -- å•†å“ã‚³ãƒ¼ãƒ‰
    name VARCHAR(255) NOT NULL,              -- å•†å“å
    description TEXT,                        -- å•†å“èª¬æ˜
    category VARCHAR(100),                   -- ã‚«ãƒ†ã‚´ãƒª
    
    stock_quantity INTEGER DEFAULT 0,       -- åœ¨åº«æ•°é‡
    reserved_quantity INTEGER DEFAULT 0,    -- äºˆç´„æ¸ˆã¿æ•°é‡
    
    weight FLOAT,                           -- é‡é‡(g)
    dimensions VARCHAR(100),                -- ã‚µã‚¤ã‚º
    
    cost_price FLOAT DEFAULT 0.0,          -- åŸä¾¡
    min_stock_level INTEGER DEFAULT 10,    -- æœ€å°åœ¨åº«ãƒ¬ãƒ™ãƒ«
    max_stock_level INTEGER DEFAULT 1000,  -- æœ€å¤§åœ¨åº«ãƒ¬ãƒ™ãƒ«
    
    is_active BOOLEAN DEFAULT true,        -- æœ‰åŠ¹ãƒ•ãƒ©ã‚°
    is_trackable BOOLEAN DEFAULT true,     -- è¿½è·¡å¯èƒ½ãƒ•ãƒ©ã‚°
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_inventory_sku ON inventory_items(sku);
CREATE INDEX idx_inventory_category ON inventory_items(category);
CREATE INDEX idx_inventory_stock_level ON inventory_items(stock_quantity);
```

#### ä¾¡æ ¼ãƒ†ãƒ¼ãƒ–ãƒ« (`prices`)
```sql
CREATE TABLE prices (
    id SERIAL PRIMARY KEY,
    inventory_id INTEGER REFERENCES inventory_items(id) ON DELETE CASCADE,
    
    selling_price FLOAT NOT NULL,          -- è²©å£²ä¾¡æ ¼
    cost_price FLOAT NOT NULL,             -- åŸä¾¡
    discount_price FLOAT,                  -- å‰²å¼•ä¾¡æ ¼
    currency VARCHAR(3) DEFAULT 'JPY',     -- é€šè²¨
    
    margin_percent FLOAT,                  -- ãƒãƒ¼ã‚¸ãƒ³ç‡
    markup_percent FLOAT,                  -- ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—ç‡
    
    is_active BOOLEAN DEFAULT true,        -- æœ‰åŠ¹ãƒ•ãƒ©ã‚°
    requires_approval BOOLEAN DEFAULT false, -- æ‰¿èªè¦æ±‚ãƒ•ãƒ©ã‚°
    
    effective_from TIMESTAMP WITH TIME ZONE DEFAULT NOW(), -- æœ‰åŠ¹é–‹å§‹æ—¥
    effective_until TIMESTAMP WITH TIME ZONE,             -- æœ‰åŠ¹çµ‚äº†æ—¥
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_prices_inventory_id ON prices(inventory_id);
CREATE INDEX idx_prices_effective_period ON prices(effective_from, effective_until);
```

### ğŸ” ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥
```sql
-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã‚ˆãä¸€ç·’ã«æ¤œç´¢ã•ã‚Œã‚‹åˆ—ï¼‰
CREATE INDEX idx_inventory_category_active ON inventory_items(category, is_active);
CREATE INDEX idx_prices_active_effective ON prices(is_active, effective_from, effective_until);

-- éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆæ¡ä»¶ä»˜ãã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
CREATE INDEX idx_low_stock_items ON inventory_items(stock_quantity) 
    WHERE stock_quantity <= min_stock_level;

-- é–¢æ•°ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_available_quantity ON inventory_items((stock_quantity - reserved_quantity));
```

#### ã‚¯ã‚¨ãƒªæœ€é©åŒ–ä¾‹
```python
# æ‚ªã„ä¾‹: N+1ã‚¯ã‚¨ãƒªå•é¡Œ
async def get_items_with_prices_bad():
    items = await db.execute(select(Inventory))
    for item in items:
        prices = await db.execute(select(Price).where(Price.inventory_id == item.id))
        
# è‰¯ã„ä¾‹: JOINã‚’ä½¿ç”¨
async def get_items_with_prices_good():
    result = await db.execute(
        select(Inventory, Price)
        .join(Price, Inventory.id == Price.inventory_id)
        .options(selectinload(Inventory.prices))  # é–¢é€£ãƒ‡ãƒ¼ã‚¿ã®äº‹å‰èª­ã¿è¾¼ã¿
    )
    return result.all()
```

---

## ğŸ”Œ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡

### ğŸŒ WebSocket ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### WebSocket Manager è¨­è¨ˆ
```python
# services/websocket_manager.py
import asyncio
import json
from typing import Dict, List, Set
from fastapi import WebSocket
from app.core.redis_client import get_redis_client

class WebSocketManager:
    def __init__(self):
        # æ¥ç¶šã‚¿ã‚¤ãƒ—åˆ¥ã«WebSocketæ¥ç¶šã‚’ç®¡ç†
        self.connections: Dict[str, Set[WebSocket]] = {
            "inventory": set(),
            "price": set(),
            "general": set()
        }
        self.redis_subscribers: Dict[str, object] = {}
        
    async def connect(self, websocket: WebSocket, connection_type: str = "general"):
        """WebSocketæ¥ç¶šã®å—ã‘å…¥ã‚Œ"""
        await websocket.accept()
        self.connections[connection_type].add(websocket)
        
        # Redisè³¼èª­ã®é–‹å§‹ï¼ˆåˆå›æ¥ç¶šæ™‚ï¼‰
        if not self.redis_subscribers.get(connection_type):
            await self._start_redis_subscription(connection_type)
            
        logger.info(
            "WebSocket client connected",
            connection_type=connection_type,
            total_connections=len(self.connections[connection_type])
        )

    async def disconnect(self, websocket: WebSocket, connection_type: str = "general"):
        """WebSocketæ¥ç¶šã®çµ‚äº†"""
        self.connections[connection_type].discard(websocket)
        
        logger.info(
            "WebSocket client disconnected",
            connection_type=connection_type,
            remaining_connections=len(self.connections[connection_type])
        )

    async def broadcast_to_type(self, connection_type: str, message: dict):
        """ç‰¹å®šã‚¿ã‚¤ãƒ—ã®æ¥ç¶šã«ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ"""
        if not self.connections[connection_type]:
            return
            
        message_str = json.dumps(message, default=str)
        disconnected = set()
        
        # å…¨æ¥ç¶šã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
        for websocket in self.connections[connection_type].copy():
            try:
                await websocket.send_text(message_str)
            except Exception:
                # åˆ‡æ–­ã•ã‚ŒãŸWebSocketã‚’è¨˜éŒ²
                disconnected.add(websocket)
                
        # åˆ‡æ–­ã•ã‚ŒãŸæ¥ç¶šã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        for websocket in disconnected:
            self.connections[connection_type].discard(websocket)
            
        logger.info(
            "Broadcasted message to WebSocket clients",
            connection_type=connection_type,
            successful_sends=len(self.connections[connection_type]),
            failed_sends=len(disconnected)
        )

    async def _start_redis_subscription(self, connection_type: str):
        """Redis Pub/Subè³¼èª­é–‹å§‹"""
        redis = await get_redis_client()
        pubsub = redis.pubsub()
        
        # ãƒãƒ£ãƒ³ãƒãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°
        channels = {
            "inventory": ["inventory:updates", "stock:alerts"],
            "price": ["price:updates", "price:alerts"],
            "general": ["system:notifications"]
        }
        
        for channel in channels.get(connection_type, []):
            await pubsub.subscribe(channel)
            
        # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡
        self.redis_subscribers[connection_type] = pubsub
        asyncio.create_task(self._listen_redis_messages(pubsub, connection_type))

    async def _listen_redis_messages(self, pubsub, connection_type: str):
        """Redis ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒªãƒƒã‚¹ãƒ³"""
        async for message in pubsub.listen():
            if message["type"] == "message":
                try:
                    data = json.loads(message["data"])
                    await self.broadcast_to_type(connection_type, data)
                except Exception as e:
                    logger.error("Redis message broadcast failed", error=str(e))
```

### ğŸ“¡ Redis Pub/Sub çµ±åˆ

#### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¬é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³
```python
# services/inventory_service.py
async def update_inventory_item(self, item_id: int, update_data: InventoryUpdate):
    """åœ¨åº«æ›´æ–°ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥"""
    
    # 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ›´æ–°
    item = await self._update_database(item_id, update_data)
    
    # 2. Redis Pub/Sub ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¬é–‹
    await self._publish_inventory_update(item)
    
    return item

async def _publish_inventory_update(self, item: Inventory):
    """åœ¨åº«æ›´æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’Redisã«å…¬é–‹"""
    redis = await get_redis_client()
    
    message = {
        "message_type": "inventory_update",
        "action": "updated",
        "item_id": item.id,
        "sku": item.sku,
        "name": item.name,
        "stock_quantity": item.stock_quantity,
        "available_quantity": item.available_quantity,
        "is_low_stock": item.is_low_stock,
        "timestamp": datetime.utcnow().isoformat()
    }
    
    await redis.publish("inventory:updates", json.dumps(message, default=str))
    
    # åœ¨åº«ä¸è¶³ã‚¢ãƒ©ãƒ¼ãƒˆã®è¿½åŠ é€ä¿¡
    if item.is_low_stock:
        alert_message = {
            "message_type": "stock_alert", 
            "alert_level": "low",
            "item_id": item.id,
            "sku": item.sku,
            "current_stock": item.available_quantity,
            "min_level": item.min_stock_level,
            "timestamp": datetime.utcnow().isoformat()
        }
        await redis.publish("stock:alerts", json.dumps(alert_message, default=str))
```

### ğŸ”„ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šç®¡ç†

#### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ WebSocket æ¥ç¶šä¾‹
```javascript
// WebSocketæ¥ç¶šã‚¯ãƒ©ã‚¹
class InventoryWebSocket {
    constructor(baseUrl = 'ws://localhost:8000') {
        this.baseUrl = baseUrl;
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectInterval = 5000;
    }

    connect() {
        try {
            this.socket = new WebSocket(`${this.baseUrl}/ws/inventory`);
            
            this.socket.onopen = (event) => {
                console.log('âœ… åœ¨åº«ç›£è¦–WebSocketæ¥ç¶šé–‹å§‹');
                this.reconnectAttempts = 0;
            };
            
            this.socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            };
            
            this.socket.onclose = (event) => {
                console.log('ğŸ”Œ åœ¨åº«ç›£è¦–WebSocketæ¥ç¶šçµ‚äº†');
                this.attemptReconnect();
            };
            
            this.socket.onerror = (error) => {
                console.error('âŒ WebSocket ã‚¨ãƒ©ãƒ¼:', error);
            };
            
        } catch (error) {
            console.error('WebSocketæ¥ç¶šå¤±æ•—:', error);
            this.attemptReconnect();
        }
    }

    handleMessage(data) {
        switch (data.message_type) {
            case 'inventory_update':
                this.onInventoryUpdate(data);
                break;
            case 'stock_alert':
                this.onStockAlert(data);
                break;
            default:
                console.log('æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—:', data);
        }
    }

    onInventoryUpdate(data) {
        // UIæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
        console.log(`ğŸ“¦ åœ¨åº«æ›´æ–°: ${data.sku} -> ${data.stock_quantity}å€‹`);
        this.updateInventoryUI(data);
    }

    onStockAlert(data) {
        // ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
        console.log(`âš ï¸ åœ¨åº«ä¸è¶³: ${data.sku}`);
        this.showStockAlert(data);
    }

    attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('æœ€å¤§å†æ¥ç¶šè©¦è¡Œå›æ•°ã«åˆ°é”');
            return;
        }

        this.reconnectAttempts++;
        console.log(`ğŸ”„ å†æ¥ç¶šè©¦è¡Œ (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        
        setTimeout(() => {
            this.connect();
        }, this.reconnectInterval);
    }

    disconnect() {
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
    }
}

// ä½¿ç”¨ä¾‹
const inventoryWS = new InventoryWebSocket();
inventoryWS.connect();
```

---

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æˆ¦ç•¥

#### 1. èªè¨¼ãƒ»èªå¯ (JWT)
```python
# core/security.py
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, Depends, status
from fastapi.security import HTTPBearer

security = HTTPBearer()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class SecurityManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
    
    def create_access_token(self, data: dict, expires_delta: timedelta = None):
        """ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
            
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str):
        """ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            username: str = payload.get("sub")
            if username is None:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid authentication credentials",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            return payload
        except JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials", 
                headers={"WWW-Authenticate": "Bearer"},
            )

# ä¾å­˜æ€§æ³¨å…¥
async def get_current_user(token: str = Depends(security)):
    security_manager = SecurityManager(settings.SECRET_KEY)
    return security_manager.verify_token(token)
```

#### 2. ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–
```python
# schemas/security.py
from pydantic import BaseModel, Field, validator
import re

class SecureInventoryCreate(BaseModel):
    sku: str = Field(..., min_length=3, max_length=50)
    name: str = Field(..., min_length=1, max_length=200)
    
    @validator('sku')
    def validate_sku(cls, v):
        # è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿è¨±å¯
        if not re.match(r'^[A-Za-z0-9\-]+$', v):
            raise ValueError('SKUã¯è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™')
        return v.upper()
    
    @validator('name')
    def validate_name(cls, v):
        # XSSæ”»æ’ƒå¯¾ç­–ï¼šHTMLã‚¿ã‚°é™¤å»
        if '<' in v or '>' in v:
            raise ValueError('å•†å“åã«HTMLã‚¿ã‚°ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“')
        return v.strip()
```

#### 3. CORSè¨­å®š
```python
# main.py
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,  # è¨±å¯ã™ã‚‹ã‚ªãƒªã‚¸ãƒ³
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
```

#### 4. ãƒ¬ãƒ¼ãƒˆåˆ¶é™
```python
# middleware/rate_limit.py
from fastapi import Request, HTTPException
from datetime import datetime, timedelta
from app.core.redis_client import get_redis_client

class RateLimitMiddleware:
    def __init__(self, calls: int = 100, period: int = 60):
        self.calls = calls
        self.period = period
    
    async def __call__(self, request: Request, call_next):
        # ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIPã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾—
        client_ip = request.client.host
        redis = await get_redis_client()
        
        # Redis ã‚­ãƒ¼ã®ç”Ÿæˆ
        key = f"rate_limit:{client_ip}"
        
        # ç¾åœ¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°å–å¾—
        current_calls = await redis.get(key)
        
        if current_calls is None:
            # åˆå›ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            await redis.setex(key, self.period, 1)
        elif int(current_calls) >= self.calls:
            # ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«é”ã—ãŸ
            raise HTTPException(
                status_code=429,
                detail="Rate limit exceeded"
            )
        else:
            # ã‚«ã‚¦ãƒ³ã‚¿å¢—åŠ 
            await redis.incr(key)
        
        response = await call_next(request)
        return response
```

### ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»

#### 1. è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
```bash
# ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
pip install safety
safety check -r requirements.txt

# SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ç¢ºèª
grep -r "f\".*{" app/  # f-stringã§ã®SQLçµ„ã¿ç«‹ã¦ãƒã‚§ãƒƒã‚¯

# æ©Ÿå¯†æƒ…å ±ã®æ¼æ´©ãƒã‚§ãƒƒã‚¯
grep -r "password\|secret\|key" app/ --exclude="*.pyc"
```

#### 2. ãƒ­ã‚°ç›£è¦–
```python
# core/logging.py
import structlog
from datetime import datetime

def setup_logging():
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°
async def log_security_event(event_type: str, details: dict, request: Request):
    logger = structlog.get_logger()
    logger.warning(
        "Security event detected",
        event_type=event_type,
        client_ip=request.client.host,
        user_agent=request.headers.get("user-agent"),
        timestamp=datetime.utcnow().isoformat(),
        details=details
    )
```

---

## ğŸ“ˆ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£

### ğŸ”„ æ°´å¹³ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æˆ¦ç•¥

#### 1. ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µè¨­å®š
```nginx
# nginx.conf
upstream fastapi_backend {
    server backend1:8000;
    server backend2:8000; 
    server backend3:8000;
}

server {
    listen 80;
    server_name api.inventory-monitor.com;
    
    location / {
        proxy_pass http://fastapi_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
    location /ws/ {
        proxy_pass http://fastapi_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}
```

#### 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿å–ã‚Šåˆ†æ•£
```python
# core/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession

class DatabaseManager:
    def __init__(self):
        # ãƒã‚¹ã‚¿ãƒ¼ï¼ˆæ›¸ãè¾¼ã¿ç”¨ï¼‰
        self.write_engine = create_async_engine(settings.WRITE_DATABASE_URL)
        
        # ã‚¹ãƒ¬ãƒ¼ãƒ–ï¼ˆèª­ã¿å–ã‚Šç”¨ï¼‰
        self.read_engines = [
            create_async_engine(settings.READ_DATABASE_URL_1),
            create_async_engine(settings.READ_DATABASE_URL_2),
        ]
        self.read_engine_index = 0
    
    async def get_write_session(self) -> AsyncSession:
        """æ›¸ãè¾¼ã¿ç”¨ã‚»ãƒƒã‚·ãƒ§ãƒ³"""
        return AsyncSession(self.write_engine)
    
    async def get_read_session(self) -> AsyncSession:
        """èª­ã¿å–ã‚Šç”¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°ï¼‰"""
        engine = self.read_engines[self.read_engine_index]
        self.read_engine_index = (self.read_engine_index + 1) % len(self.read_engines)
        return AsyncSession(engine)

# ã‚µãƒ¼ãƒ“ã‚¹å±¤ã§ã®ä½¿ç”¨
class InventoryService:
    async def get_inventory_list(self):
        # èª­ã¿å–ã‚Šå°‚ç”¨æ“ä½œ
        async with database_manager.get_read_session() as session:
            return await session.execute(select(Inventory))
    
    async def create_inventory_item(self, data):
        # æ›¸ãè¾¼ã¿æ“ä½œ
        async with database_manager.get_write_session() as session:
            # ä½œæˆå‡¦ç†
            pass
```

#### 3. Redis Cluster
```python
# core/redis_client.py
import aioredis
from aioredis.cluster import RedisCluster

async def get_redis_cluster():
    """Redis ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¥ç¶š"""
    startup_nodes = [
        {"host": "redis-node1", "port": 7000},
        {"host": "redis-node2", "port": 7000}, 
        {"host": "redis-node3", "port": 7000},
    ]
    return RedisCluster(startup_nodes=startup_nodes)
```

### ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

#### 1. ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
```python
# monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge
import time
from functools import wraps

# ãƒ¡ãƒˆãƒªã‚¯ã‚¹å®šç¾©
REQUEST_COUNT = Counter('api_requests_total', 'Total API requests', ['method', 'endpoint'])
REQUEST_DURATION = Histogram('api_request_duration_seconds', 'Request duration')
ACTIVE_CONNECTIONS = Gauge('websocket_connections_active', 'Active WebSocket connections')
DATABASE_CONNECTIONS = Gauge('database_connections_active', 'Active database connections')

def monitor_endpoint(func):
    """ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆç›£è¦–ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = await func(*args, **kwargs)
            REQUEST_COUNT.labels(method='POST', endpoint=func.__name__).inc()
            return result
        finally:
            REQUEST_DURATION.observe(time.time() - start_time)
    
    return wrapper

# ä½¿ç”¨ä¾‹
@router.post("/")
@monitor_endpoint
async def create_inventory_item(item: InventoryCreate):
    # å‡¦ç†
    pass
```

#### 2. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ‹¡å¼µ
```python
# api/health.py
from fastapi import APIRouter, HTTPException
from sqlalchemy import text
from app.core.database import get_async_session
from app.core.redis_client import get_redis_client

router = APIRouter()

@router.get("/health/detailed")
async def detailed_health_check():
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
    try:
        async with get_async_session() as session:
            await session.execute(text("SELECT 1"))
        health_status["services"]["database"] = {"status": "healthy"}
    except Exception as e:
        health_status["services"]["database"] = {"status": "unhealthy", "error": str(e)}
        health_status["status"] = "unhealthy"
    
    # Redisæ¥ç¶šãƒã‚§ãƒƒã‚¯
    try:
        redis = await get_redis_client()
        await redis.ping()
        health_status["services"]["redis"] = {"status": "healthy"}
    except Exception as e:
        health_status["services"]["redis"] = {"status": "unhealthy", "error": str(e)}
        health_status["status"] = "unhealthy"
    
    if health_status["status"] == "unhealthy":
        raise HTTPException(status_code=503, detail=health_status)
    
    return health_status
```

---

## ğŸ“Š ç›£è¦–ãƒ»ãƒ­ã‚°

### ğŸ“ˆ ãƒ­ã‚°æˆ¦ç•¥

#### 1. æ§‹é€ åŒ–ãƒ­ã‚°
```python
# core/logging_config.py
import structlog
from pythonjsonlogger import jsonlogger

def configure_logging():
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.processors.add_log_level,
            structlog.processors.add_logger_name,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.JSONRenderer()
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        context_class=structlog.threadlocal.wrap_dict(dict),
        cache_logger_on_first_use=True,
    )

# ã‚µãƒ¼ãƒ“ã‚¹å†…ã§ã®ä½¿ç”¨
logger = structlog.get_logger()

async def create_inventory_item(self, item_data: InventoryCreate):
    logger.info(
        "Creating inventory item",
        sku=item_data.sku,
        category=item_data.category,
        stock_quantity=item_data.stock_quantity
    )
    
    try:
        # å‡¦ç†
        result = await self._create_item(item_data)
        
        logger.info(
            "Inventory item created successfully",
            item_id=result.id,
            sku=result.sku
        )
        
        return result
        
    except Exception as e:
        logger.error(
            "Failed to create inventory item",
            sku=item_data.sku,
            error=str(e),
            error_type=type(e).__name__
        )
        raise
```

#### 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹
```python
# monitoring/app_metrics.py
from dataclasses import dataclass
from typing import Dict
import asyncio

@dataclass
class ApplicationMetrics:
    total_requests: int = 0
    failed_requests: int = 0
    active_websockets: int = 0
    cache_hit_rate: float = 0.0
    average_response_time: float = 0.0
    inventory_items_count: int = 0
    low_stock_alerts: int = 0

class MetricsCollector:
    def __init__(self):
        self.metrics = ApplicationMetrics()
        self.response_times = []
    
    async def collect_database_metrics(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†"""
        async with get_async_session() as session:
            # åœ¨åº«ã‚¢ã‚¤ãƒ†ãƒ æ•°
            result = await session.execute(select(func.count(Inventory.id)))
            self.metrics.inventory_items_count = result.scalar()
            
            # åœ¨åº«ä¸è¶³ã‚¢ã‚¤ãƒ†ãƒ æ•°
            low_stock_result = await session.execute(
                select(func.count(Inventory.id))
                .where(Inventory.stock_quantity <= Inventory.min_stock_level)
            )
            self.metrics.low_stock_alerts = low_stock_result.scalar()
    
    async def collect_cache_metrics(self):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†"""
        redis = await get_redis_client()
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        cache_hits = await redis.get("metrics:cache_hits") or 0
        cache_misses = await redis.get("metrics:cache_misses") or 0
        
        total_requests = int(cache_hits) + int(cache_misses)
        if total_requests > 0:
            self.metrics.cache_hit_rate = int(cache_hits) / total_requests
    
    def record_response_time(self, duration: float):
        """ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“è¨˜éŒ²"""
        self.response_times.append(duration)
        if len(self.response_times) > 1000:  # ç›´è¿‘1000ä»¶ã®ã¿ä¿æŒ
            self.response_times = self.response_times[-1000:]
        
        self.metrics.average_response_time = sum(self.response_times) / len(self.response_times)
    
    async def export_metrics(self) -> Dict:
        """ãƒ¡ãƒˆãƒªã‚¯ã‚¹å‡ºåŠ›"""
        await asyncio.gather(
            self.collect_database_metrics(),
            self.collect_cache_metrics()
        )
        
        return {
            "application": {
                "total_requests": self.metrics.total_requests,
                "failed_requests": self.metrics.failed_requests,
                "success_rate": 1 - (self.metrics.failed_requests / max(1, self.metrics.total_requests)),
                "average_response_time_ms": self.metrics.average_response_time * 1000
            },
            "business": {
                "inventory_items_total": self.metrics.inventory_items_count,
                "low_stock_alerts": self.metrics.low_stock_alerts
            },
            "infrastructure": {
                "active_websockets": self.metrics.active_websockets,
                "cache_hit_rate": self.metrics.cache_hit_rate
            }
        }

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼
metrics_collector = MetricsCollector()
```

### ğŸ¯ ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

#### Grafana Dashboard è¨­å®šä¾‹
```json
{
  "dashboard": {
    "title": "åœ¨åº«ãƒ»ä¾¡æ ¼ç›£è¦–API ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰",
    "panels": [
      {
        "title": "APIãƒªã‚¯ã‚¨ã‚¹ãƒˆç‡",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(api_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“",
        "type": "graph", 
        "targets": [
          {
            "expr": "histogram_quantile(0.95, api_request_duration_seconds_bucket)",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "title": "åœ¨åº«ã‚¢ãƒ©ãƒ¼ãƒˆ",
        "type": "singlestat",
        "targets": [
          {
            "expr": "inventory_low_stock_alerts_total",
            "legendFormat": "åœ¨åº«ä¸è¶³ã‚¢ã‚¤ãƒ†ãƒ æ•°"
          }
        ]
      }
    ]
  }
}
```

---

## ğŸ¯ ã¾ã¨ã‚

### ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç‰¹å¾´

1. **ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†é›¢**: æ˜ç¢ºãªè²¬å‹™åˆ†é›¢ã«ã‚ˆã‚‹ä¿å®ˆæ€§å‘ä¸Š
2. **éåŒæœŸå‡¦ç†**: é«˜ä¸¦è¡Œæ€§èƒ½ã¨ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡æ€§
3. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡**: WebSocket + Redis Pub/Sub ã«ã‚ˆã‚‹å³åº§ãƒ‡ãƒ¼ã‚¿é…ä¿¡
4. **å‹å®‰å…¨æ€§**: Pydantic ã«ã‚ˆã‚‹å³å¯†ãªãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
5. **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**: æ°´å¹³ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å¯¾å¿œè¨­è¨ˆ

### ğŸš€ é‹ç”¨ã«ãŠã‘ã‚‹åˆ©ç‚¹

- **é–‹ç™ºåŠ¹ç‡**: æ˜ç¢ºãªæ§‹é€ ã«ã‚ˆã‚‹é–‹ç™ºé€Ÿåº¦å‘ä¸Š
- **ä¿å®ˆæ€§**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆ†é›¢ã«ã‚ˆã‚‹å½±éŸ¿ç¯„å›²é™å®š
- **æ‹¡å¼µæ€§**: æ–°æ©Ÿèƒ½è¿½åŠ æ™‚ã®æ—¢å­˜ã‚³ãƒ¼ãƒ‰å½±éŸ¿æœ€å°åŒ–
- **æ€§èƒ½**: éåŒæœŸå‡¦ç†ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã«ã‚ˆã‚‹é«˜æ€§èƒ½
- **ç›£è¦–æ€§**: æ§‹é€ åŒ–ãƒ­ã‚°ã¨è©³ç´°ãƒ¡ãƒˆãƒªã‚¯ã‚¹

### ğŸ“š æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–**: å°†æ¥çš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²è¨­è¨ˆ
2. **Kuberneteså¯¾å¿œ**: ã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
3. **CI/CDçµ±åˆ**: è‡ªå‹•ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ
4. **API Gateway**: çµ±ä¸€ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
5. **åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°**: ãƒªã‚¯ã‚¨ã‚¹ãƒˆè¿½è·¡ã‚·ã‚¹ãƒ†ãƒ 

**ğŸŠ FastAPI ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆãƒã‚¹ã‚¿ãƒ¼å®Œäº†ã§ã™ï¼æœ¬æ ¼çš„ãªã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åŸºç›¤ãŒå®Œæˆã—ã¾ã—ãŸã€‚**