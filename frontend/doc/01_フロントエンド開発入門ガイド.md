# フロントエンド開発入門ガイド

リアルタイム在庫・価格監視システムのフロントエンド開発を初心者にもわかりやすく解説します。

## 📚 目次

1. [事前知識と準備](#事前知識と準備)
2. [開発環境セットアップ](#開発環境セットアップ)
3. [プロジェクト構造の理解](#プロジェクト構造の理解)
4. [基本概念の学習](#基本概念の学習)
5. [段階別実装手順](#段階別実装手順)

---

## 事前知識と準備

### 🎯 必要な基礎知識

#### HTML/CSS の基本 (重要度: ⭐⭐⭐⭐⭐)
```html
<!-- HTMLの基本構造を理解していること -->
<!DOCTYPE html>
<html>
  <head>
    <title>ページタイトル</title>
  </head>
  <body>
    <div class="container">
      <h1>見出し</h1>
      <p>段落テキスト</p>
    </div>
  </body>
</html>
```

#### JavaScript の基本 (重要度: ⭐⭐⭐⭐⭐)
```javascript
// 変数、関数、オブジェクトの基本を理解していること
const message = "Hello World";
function greetUser(name) {
  return `こんにちは、${name}さん`;
}
const user = { name: "田中", age: 25 };
```

#### Node.js とnpm の基本 (重要度: ⭐⭐⭐⭐)
```bash
# パッケージ管理とコマンドライン操作を理解していること
npm install package-name
npm run script-name
npm start
```

### 🛠️ 必要なソフトウェア

1. **Node.js 18以上** - JavaScript実行環境
2. **npm 9以上** - パッケージマネージャー
3. **VSCode** - 推奨エディター
4. **Git** - バージョン管理ツール

### 📖 学習リソース

- **React公式チュートリアル**: https://react.dev/learn
- **Next.js公式ドキュメント**: https://nextjs.org/docs
- **TypeScript Handbook**: https://www.typescriptlang.org/docs/

---

## 開発環境セットアップ

### ステップ1: 前提条件確認

```bash
# バージョン確認
node --version  # v18.0.0 以上であることを確認
npm --version   # v9.0.0 以上であることを確認
git --version   # インストールされていることを確認
```

### ステップ2: プロジェクトクローンと依存関係インストール

```bash
# 1. プロジェクトディレクトリに移動
cd /path/to/real-time-inventory-and-price-fluctuation-monitoring-api

# 2. フロントエンドディレクトリに移動
cd frontend

# 3. 依存関係をインストール
npm install

# 4. インストールが完了したら内容を確認
ls -la node_modules  # パッケージが正常にインストールされているか確認
```

### ステップ3: 開発サーバー起動

```bash
# バックエンドAPIが起動していることを前提として
# フロントエンド開発サーバーを起動
npm run dev

# または Next.js を直接起動
npx next dev
```

**✅ 成功確認**: ブラウザで http://localhost:3000 にアクセスできること

---

## プロジェクト構造の理解

### 📁 ディレクトリ構造

```
frontend/
├── src/                           # ソースコードのメインディレクトリ
│   ├── app/                       # Next.js App Router (ページ構成)
│   │   ├── globals.css            # 全体に適用されるスタイル
│   │   ├── layout.tsx             # アプリ全体のレイアウト
│   │   ├── page.tsx               # メインページ (ダッシュボード)
│   │   └── providers.tsx          # データ管理の設定
│   │   
│   ├── components/                # 再利用可能なUIパーツ
│   │   ├── dashboard/             # ダッシュボード関連のコンポーネント
│   │   │   └── DashboardStats.tsx # 統計表示コンポーネント
│   │   ├── inventory/             # 在庫管理関連のコンポーネント
│   │   │   └── InventoryTable.tsx # 在庫テーブルコンポーネント
│   │   ├── alerts/                # アラート関連のコンポーネント
│   │   │   └── LowStockAlert.tsx  # 低在庫警告コンポーネント
│   │   └── ui/                    # 基本的なUIコンポーネント
│   │       ├── LoadingSpinner.tsx # 読み込み中表示
│   │       ├── ErrorMessage.tsx   # エラーメッセージ表示
│   │       └── PageHeader.tsx     # ページヘッダー
│   │
│   └── lib/                       # ビジネスロジックとユーティリティ
│       ├── api/                   # API関連の処理
│       │   ├── types.ts           # TypeScript型定義
│       │   └── client.ts          # APIクライアント
│       ├── hooks/                 # カスタムReact Hooks
│       │   ├── use-inventory.ts   # 在庫データ管理
│       │   └── use-websocket.ts   # リアルタイム通信
│       └── websocket/             # WebSocket通信管理
│           └── client.ts          # WebSocket接続管理
│
├── public/                        # 静的ファイル (画像など)
├── next.config.js                 # Next.js設定ファイル
├── tailwind.config.js             # スタイリング設定
├── tsconfig.json                  # TypeScript設定
└── package.json                   # プロジェクト設定と依存関係
```

### 🎯 各ファイルの役割

#### `src/app/page.tsx` - メインページ
```typescript
// ダッシュボードのメイン画面
// 統計、在庫テーブル、アラートを表示
export default function DashboardPage() {
  // ページの内容を定義
}
```

#### `src/components/` - UIコンポーネント
```typescript
// 再利用可能なUIパーツを定義
// 例：ボタン、テーブル、モーダルなど
export function InventoryTable({ data }) {
  // テーブルの表示ロジック
}
```

#### `src/lib/` - ビジネスロジック
```typescript
// データ取得、API通信、状態管理など
// UIから分離された処理ロジック
export function useInventoryList() {
  // 在庫データの取得と管理
}
```

---

## 基本概念の学習

### 🔧 技術スタックの理解

#### 1. **Next.js** - Reactフレームワーク
```typescript
// Next.jsの特徴
// ✅ ルーティング自動生成
// ✅ サーバーサイドレンダリング
// ✅ パフォーマンス最適化

// src/app/page.tsx = http://localhost:3000/
// src/app/about/page.tsx = http://localhost:3000/about
```

#### 2. **React** - UIライブラリ
```typescript
// コンポーネントベースの開発
function GreetingComponent({ name }: { name: string }) {
  return <h1>こんにちは、{name}さん！</h1>;
}

// 使用例
<GreetingComponent name="田中" />
```

#### 3. **TypeScript** - 型安全なJavaScript
```typescript
// 型を定義してエラーを予防
interface User {
  id: number;
  name: string;
  email: string;
}

function getUserInfo(user: User): string {
  return `${user.name} (${user.email})`;
}
```

#### 4. **Tailwind CSS** - スタイリング
```typescript
// クラス名でスタイルを適用
<div className="bg-blue-500 text-white p-4 rounded-lg">
  青い背景の角丸ボックス
</div>
```

#### 5. **React Query** - データ管理
```typescript
// サーバーデータの取得と管理
function useInventoryData() {
  return useQuery({
    queryKey: ['inventory'],
    queryFn: () => fetch('/api/inventory').then(res => res.json())
  });
}
```

### 🌐 データフローの理解

```
1. ユーザーがページを開く
   ↓
2. React QueryがバックエンドAPIからデータを取得
   ↓  
3. 取得したデータをReactコンポーネントで表示
   ↓
4. WebSocketでリアルタイム更新を受信
   ↓
5. UIが自動的に更新される
```

---

## 段階別実装手順

### フェーズ1: 基本ページ作成 (初級)

#### 目標
- シンプルなダッシュボードページを作成
- 静的データでUI表示を確認

#### 手順1: メインページの作成

```typescript
// src/app/page.tsx
export default function DashboardPage() {
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-6">
        在庫管理ダッシュボード
      </h1>
      
      {/* 統計表示エリア */}
      <div className="grid grid-cols-3 gap-4 mb-8">
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">総商品数</h2>
          <p className="text-3xl font-bold text-blue-600">150</p>
        </div>
        
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">低在庫</h2>
          <p className="text-3xl font-bold text-yellow-600">5</p>
        </div>
        
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">在庫切れ</h2>
          <p className="text-3xl font-bold text-red-600">2</p>
        </div>
      </div>

      {/* 在庫テーブルエリア */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">在庫一覧</h2>
        <p className="text-gray-600">在庫テーブルがここに表示されます</p>
      </div>
    </div>
  );
}
```

#### 手順2: 動作確認

```bash
# 開発サーバーを起動
npm run dev

# ブラウザで確認
# http://localhost:3000
```

**✅ 確認ポイント**:
- ページが正常に表示される
- 統計カードが3つ横並びで表示される
- レスポンシブ対応（画面サイズを変えても崩れない）

---

### フェーズ2: API連携実装 (中級)

#### 目標
- バックエンドAPIからデータを取得
- React Queryを使用したデータ管理

#### 手順1: API型定義の理解

```typescript
// src/lib/api/types.ts を確認
interface InventoryItem {
  id: number;           // 商品ID
  name: string;         // 商品名
  sku: string;          // SKU
  category: string;     // カテゴリ
  stock_quantity: number; // 在庫数
  min_stock_level: number; // 最小在庫レベル
  selling_price: number;   // 販売価格
  // ... その他のプロパティ
}
```

#### 手順2: React Query Hookの使用

```typescript
// src/app/page.tsx を更新
'use client'

import { useInventoryList } from '@/lib/hooks/use-inventory';

export default function DashboardPage() {
  // React Queryでデータ取得
  const { 
    data: inventoryData, 
    isLoading, 
    error 
  } = useInventoryList(0, 20);

  // ローディング状態の表示
  if (isLoading) {
    return (
      <div className="p-8">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-2">データを読み込んでいます...</p>
        </div>
      </div>
    );
  }

  // エラー状態の表示
  if (error) {
    return (
      <div className="p-8">
        <div className="text-center text-red-600">
          <p>データの取得に失敗しました</p>
          <p className="text-sm">{error.message}</p>
        </div>
      </div>
    );
  }

  // データの表示
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-6">
        在庫管理ダッシュボード
      </h1>
      
      {/* 実データを使用した統計表示 */}
      <div className="grid grid-cols-3 gap-4 mb-8">
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">総商品数</h2>
          <p className="text-3xl font-bold text-blue-600">
            {inventoryData?.total || 0}
          </p>
        </div>
        
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">低在庫</h2>
          <p className="text-3xl font-bold text-yellow-600">
            {inventoryData?.items?.filter(item => 
              item.stock_quantity <= item.min_stock_level
            ).length || 0}
          </p>
        </div>
        
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-lg font-semibold">在庫切れ</h2>
          <p className="text-3xl font-bold text-red-600">
            {inventoryData?.items?.filter(item => 
              item.stock_quantity === 0
            ).length || 0}
          </p>
        </div>
      </div>

      {/* 在庫一覧表示 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">在庫一覧</h2>
        {inventoryData?.items && inventoryData.items.length > 0 ? (
          <div className="grid gap-4">
            {inventoryData.items.slice(0, 5).map(item => (
              <div key={item.id} className="border rounded p-4">
                <div className="flex justify-between items-center">
                  <div>
                    <h3 className="font-semibold">{item.name}</h3>
                    <p className="text-sm text-gray-600">SKU: {item.sku}</p>
                  </div>
                  <div className="text-right">
                    <p className="font-bold">在庫: {item.stock_quantity}</p>
                    <p className="text-sm text-gray-600">¥{item.selling_price.toLocaleString()}</p>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <p className="text-gray-600">在庫データがありません</p>
        )}
      </div>
    </div>
  );
}
```

#### 手順3: 動作確認

```bash
# バックエンドAPIが起動していることを確認
curl http://localhost:8000/api/v1/inventory/

# フロントエンドで確認
# http://localhost:3000
```

**✅ 確認ポイント**:
- ローディング状態が表示される
- 実際のデータが統計に反映される
- 在庫一覧に実データが表示される
- エラーハンドリングが動作する

---

### フェーズ3: コンポーネント化 (中級〜上級)

#### 目標
- 再利用可能なコンポーネントに分割
- コードの保守性を向上

#### 手順1: 統計カードコンポーネントの作成

```typescript
// src/components/dashboard/StatCard.tsx
interface StatCardProps {
  title: string;
  value: number;
  color: 'blue' | 'yellow' | 'red';
}

export function StatCard({ title, value, color }: StatCardProps) {
  const colorClasses = {
    blue: 'text-blue-600',
    yellow: 'text-yellow-600', 
    red: 'text-red-600'
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <h2 className="text-lg font-semibold">{title}</h2>
      <p className={`text-3xl font-bold ${colorClasses[color]}`}>
        {value}
      </p>
    </div>
  );
}
```

#### 手順2: 在庫アイテムコンポーネントの作成

```typescript
// src/components/inventory/InventoryItem.tsx
import type { InventoryItem } from '@/lib/api/types';

interface InventoryItemProps {
  item: InventoryItem;
}

export function InventoryItem({ item }: InventoryItemProps) {
  // 在庫状況の判定
  const getStockStatus = () => {
    if (item.stock_quantity === 0) return { text: '在庫切れ', color: 'text-red-600' };
    if (item.stock_quantity <= item.min_stock_level) return { text: '低在庫', color: 'text-yellow-600' };
    return { text: '正常', color: 'text-green-600' };
  };

  const status = getStockStatus();

  return (
    <div className="border rounded p-4 hover:bg-gray-50 transition-colors">
      <div className="flex justify-between items-center">
        <div className="flex-1">
          <h3 className="font-semibold">{item.name}</h3>
          <p className="text-sm text-gray-600">SKU: {item.sku}</p>
          <p className="text-sm text-gray-600">カテゴリ: {item.category}</p>
        </div>
        
        <div className="text-right">
          <p className="font-bold">在庫: {item.stock_quantity}</p>
          <p className={`text-sm font-medium ${status.color}`}>
            {status.text}
          </p>
          <p className="text-sm text-gray-600">
            ¥{item.selling_price.toLocaleString()}
          </p>
        </div>
      </div>
      
      {/* 在庫レベルの視覚化 */}
      <div className="mt-3">
        <div className="flex justify-between text-xs text-gray-500 mb-1">
          <span>在庫レベル</span>
          <span>{item.stock_quantity} / {item.max_stock_level}</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div 
            className={`h-2 rounded-full ${
              status.color.includes('red') ? 'bg-red-500' : 
              status.color.includes('yellow') ? 'bg-yellow-500' : 
              'bg-green-500'
            }`}
            style={{ 
              width: `${Math.min((item.stock_quantity / item.max_stock_level) * 100, 100)}%` 
            }}
          />
        </div>
      </div>
    </div>
  );
}
```

#### 手順3: メインページの更新

```typescript
// src/app/page.tsx を更新（コンポーネント化版）
'use client'

import { useInventoryList } from '@/lib/hooks/use-inventory';
import { StatCard } from '@/components/dashboard/StatCard';
import { InventoryItem } from '@/components/inventory/InventoryItem';

export default function DashboardPage() {
  const { 
    data: inventoryData, 
    isLoading, 
    error,
    refetch 
  } = useInventoryList(0, 20);

  if (isLoading) {
    return (
      <div className="p-8">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-2">データを読み込んでいます...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-8">
        <div className="text-center text-red-600">
          <p>データの取得に失敗しました</p>
          <button 
            onClick={() => refetch()}
            className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            再試行
          </button>
        </div>
      </div>
    );
  }

  // 統計データの計算
  const stats = {
    total: inventoryData?.total || 0,
    lowStock: inventoryData?.items?.filter(item => 
      item.stock_quantity <= item.min_stock_level
    ).length || 0,
    outOfStock: inventoryData?.items?.filter(item => 
      item.stock_quantity === 0
    ).length || 0
  };

  return (
    <div className="p-8">
      {/* ヘッダー */}
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">在庫管理ダッシュボード</h1>
        <button 
          onClick={() => refetch()}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
        >
          更新
        </button>
      </div>
      
      {/* 統計カード */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
        <StatCard title="総商品数" value={stats.total} color="blue" />
        <StatCard title="低在庫" value={stats.lowStock} color="yellow" />
        <StatCard title="在庫切れ" value={stats.outOfStock} color="red" />
      </div>

      {/* 在庫一覧 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">在庫一覧</h2>
        {inventoryData?.items && inventoryData.items.length > 0 ? (
          <div className="grid gap-4">
            {inventoryData.items.map(item => (
              <InventoryItem key={item.id} item={item} />
            ))}
          </div>
        ) : (
          <p className="text-gray-600 text-center py-8">
            在庫データがありません
          </p>
        )}
      </div>
    </div>
  );
}
```

**✅ 確認ポイント**:
- コンポーネントが再利用可能になった
- コードが読みやすくなった
- 各コンポーネントが独立してテスト可能
- レスポンシブ対応が適切に動作する

---

### フェーズ4: リアルタイム機能追加 (上級)

#### 目標
- WebSocket接続を実装
- リアルタイムデータ更新を実現

#### 手順1: WebSocket接続の理解

```typescript
// src/app/page.tsx にWebSocket機能追加
'use client'

import { useInventoryList } from '@/lib/hooks/use-inventory';
import { useWebSocket } from '@/lib/hooks/use-websocket';
import { StatCard } from '@/components/dashboard/StatCard';
import { InventoryItem } from '@/components/inventory/InventoryItem';

export default function DashboardPage() {
  // データ取得
  const { 
    data: inventoryData, 
    isLoading, 
    error,
    refetch 
  } = useInventoryList(0, 20);

  // WebSocket接続
  const { isConnected, connect, disconnect } = useWebSocket();

  // 接続状況表示コンポーネント
  const ConnectionStatus = () => (
    <div className="flex items-center gap-2">
      <div className={`w-3 h-3 rounded-full ${
        isConnected ? 'bg-green-500' : 'bg-red-500'
      }`} />
      <span className="text-sm">
        {isConnected ? 'リアルタイム接続中' : '接続なし'}
      </span>
      <button
        onClick={isConnected ? disconnect : connect}
        className="text-sm text-blue-600 hover:text-blue-800"
      >
        {isConnected ? '切断' : '接続'}
      </button>
    </div>
  );

  // ... 既存のローディング・エラー処理

  return (
    <div className="p-8">
      {/* ヘッダー（接続状況追加） */}
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">在庫管理ダッシュボード</h1>
        <div className="flex items-center gap-4">
          <ConnectionStatus />
          <button 
            onClick={() => refetch()}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
          >
            更新
          </button>
        </div>
      </div>
      
      {/* 既存のUI */}
      {/* ... 統計カード・在庫一覧 */}
    </div>
  );
}
```

#### 手順2: トースト通知の追加

```typescript
// リアルタイム更新時の通知表示
import toast from 'react-hot-toast';

// WebSocket接続時の処理例（use-websocket.ts内部）
const handleMessage = useCallback((data: WebSocketMessage) => {
  try {
    if (data.type === 'inventory_update') {
      // 在庫更新通知
      toast.success(`在庫が更新されました: ${data.data?.item?.name}`, {
        icon: '📦',
        duration: 4000,
      });
    } else if (data.type === 'stock_alert') {
      // 在庫不足警告
      toast.error(`在庫不足: ${data.data?.inventory_item?.name}`, {
        icon: '⚠️',
        duration: 8000,
      });
    }
  } catch (error) {
    console.error('メッセージ処理エラー:', error);
  }
}, []);
```

**✅ 確認ポイント**:
- WebSocket接続状況が表示される
- リアルタイム更新時にトースト通知が表示される
- 接続/切断ボタンが正常に動作する
- データが自動的に更新される

---

## 🎓 学習のポイント

### デバッグ方法

#### 1. ブラウザの開発者ツール活用
```bash
# F12キーで開発者ツールを開く
# Console: エラーメッセージとログの確認
# Network: API通信の確認
# Elements: HTML/CSSの確認
```

#### 2. React Query Devtools
```typescript
// src/app/providers.tsx で有効化
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

return (
  <QueryClientProvider client={queryClient}>
    {children}
    <ReactQueryDevtools initialIsOpen={false} />
  </QueryClientProvider>
)
```

#### 3. コンソールログの活用
```typescript
// デバッグ用のログ出力
console.log('データ:', inventoryData);
console.log('ローディング状態:', isLoading);
console.log('エラー:', error);
```

### よくあるエラーと解決法

#### エラー1: "Cannot read property of undefined"
```typescript
// ❌ 危険な書き方
const itemName = inventoryData.items[0].name;

// ✅ 安全な書き方  
const itemName = inventoryData?.items?.[0]?.name || '未設定';
```

#### エラー2: "Hydration mismatch"
```typescript
// ❌ サーバーとクライアントで異なる結果
const timestamp = new Date().toISOString();

// ✅ クライアント専用で実行
const [timestamp, setTimestamp] = useState<string>('');
useEffect(() => {
  setTimestamp(new Date().toISOString());
}, []);
```

#### エラー3: "CORS error"
```typescript
// next.config.js でプロキシ設定
async rewrites() {
  return [
    {
      source: '/api/:path*',
      destination: 'http://localhost:8000/api/:path*',
    },
  ];
}
```

### パフォーマンス最適化のコツ

#### 1. メモ化の活用
```typescript
import { useMemo } from 'react';

// 重い計算をメモ化
const expensiveCalculation = useMemo(() => {
  return inventoryData?.items?.reduce((sum, item) => 
    sum + item.stock_quantity, 0
  ) || 0;
}, [inventoryData?.items]);
```

#### 2. 適切なkey指定
```typescript
// ❌ インデックスを使用
{items.map((item, index) => 
  <InventoryItem key={index} item={item} />
)}

// ✅ 一意のIDを使用
{items.map(item => 
  <InventoryItem key={item.id} item={item} />
)}
```

#### 3. 不要な再レンダリング防止
```typescript
import { memo } from 'react';

// コンポーネントをメモ化
export const InventoryItem = memo(function InventoryItem({ item }: InventoryItemProps) {
  // コンポーネントの内容
});
```

---

## 🚀 次のステップ

### 初心者向け学習課題

1. **UIカスタマイズ**: 色やレイアウトを変更してみる
2. **新しいコンポーネント作成**: 検索ボックスや フィルター機能を追加
3. **状態管理の理解**: useState、useEffectの練習

### 中級者向け学習課題

1. **フォーム実装**: 新規在庫追加フォームの作成
2. **テスト作成**: Jest、React Testing Libraryを使用
3. **パフォーマンス分析**: React Profilerの使用

### 上級者向け学習課題

1. **認証機能追加**: JWT、ログイン機能の実装
2. **SEO対応**: メタデータ、構造化データの追加
3. **PWA化**: Service Worker、オフライン機能の実装

---

📚 この教科書を通じて、モダンなReact + Next.jsアプリケーションの開発手法を段階的に学習できます。実際に手を動かしながら、各フェーズを確実に理解していきましょう！